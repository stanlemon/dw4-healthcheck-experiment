package com.example.dw.architecture;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicLong;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("Performance Rules")
class PerformanceRulesTest {

  private static JavaClasses importedClasses;

  @BeforeAll
  static void setup() {
    importedClasses =
        new ClassFileImporter()
            .withImportOption(location -> !location.contains("/test-classes/"))
            .importPackages("com.example.dw");
  }

  @Test
  @DisplayName("No reflection in performance-critical paths")
  void noReflectionInPerformanceCriticalPaths() {
    ArchRule rule =
        noClasses()
            .that()
            .resideInAnyPackage("..resources..", "..filters..", "..metrics..")
            .should()
            .callMethodWhere(
                target ->
                    target.getOwner().getPackageName().startsWith("java.lang.reflect")
                        || (target.getOwner().isAssignableTo(Class.class)
                            && (target.getName().equals("forName")
                                || target.getName().equals("getDeclaredMethod")
                                || target.getName().equals("getMethod"))))
            .because(
                "Reflection should be avoided in performance-critical paths like resources, filters, and metrics");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Use concurrent collections for thread-safe operations")
  void useConcurrentCollectionsForThreadSafeOperations() {
    ArchRule hashMapRule =
        noClasses()
            .that()
            .resideInAnyPackage("..metrics..", "..filters..")
            .should()
            .dependOnClassesThat()
            .areAssignableTo(java.util.HashMap.class)
            .because(
                "Use ConcurrentHashMap instead of HashMap in metrics and filters for thread safety");

    ArchRule linkedListRule =
        noClasses()
            .that()
            .resideInAnyPackage("..metrics..", "..filters..")
            .should()
            .dependOnClassesThat()
            .areAssignableTo(java.util.LinkedList.class)
            .because(
                "Use ConcurrentLinkedQueue instead of LinkedList in metrics and filters for thread safety");

    hashMapRule.check(importedClasses);
    linkedListRule.check(importedClasses);
  }

  @Test
  @DisplayName("Thread-safe counters should use atomic operations")
  void threadSafeCountersShouldUseAtomicOperations() {
    ArchRule rule =
        classes()
            .that()
            .resideInAPackage("..metrics..")
            .and()
            .haveFieldsThat()
            .haveRawType(long.class)
            .and()
            .areNotStatic()
            .should()
            .haveFieldsThat()
            .haveRawType(AtomicLong.class)
            .because("Use AtomicLong instead of long for thread-safe counters in metrics");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("No string concatenation in loops")
  void noStringConcatenationInLoops() {
    ArchRule rule =
        noClasses()
            .that()
            .areNotAssignableTo(PerformanceRulesTest.class)
            .should()
            .callMethodWhere(
                target ->
                    target.getOwner().isAssignableTo(String.class)
                        && target.getName().equals("concat"))
            .because(
                "Avoid string concatenation in loops - use StringBuilder for better performance");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Prefer specific collection interfaces over general ones")
  void preferSpecificCollectionInterfacesOverGeneralOnes() {
    ArchRule listRule =
        classes()
            .that()
            .resideInAnyPackage("..resources..", "..metrics..")
            .should()
            .haveFieldsThat()
            .haveRawType(java.util.List.class)
            .andHaveFieldsThat()
            .areNotAssignableTo(java.util.Collection.class)
            .because(
                "Use specific collection interfaces like List instead of general Collection interface");

    listRule.check(importedClasses);
  }

  @Test
  @DisplayName("Avoid autoboxing in performance-critical code")
  void avoidAutoboxingInPerformanceCriticalCode() {
    ArchRule rule =
        classes()
            .that()
            .resideInAnyPackage("..metrics..", "..filters..")
            .should()
            .haveFieldsThat()
            .haveRawType(long.class)
            .andHaveFieldsThat()
            .doNotHaveRawType(Long.class)
            .because(
                "Use primitive types instead of wrapper classes in performance-critical code to avoid autoboxing");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Use efficient data structures for high-frequency operations")
  void useEfficientDataStructuresForHighFrequencyOperations() {
    ArchRule concurrentHashMapRule =
        classes()
            .that()
            .resideInAPackage("..metrics..")
            .and()
            .haveFieldsThat()
            .haveRawType(java.util.Map.class)
            .should()
            .haveFieldsThat()
            .haveRawType(ConcurrentHashMap.class)
            .because("Use ConcurrentHashMap for thread-safe maps in metrics collection");

    ArchRule concurrentQueueRule =
        classes()
            .that()
            .resideInAPackage("..metrics..")
            .and()
            .haveFieldsThat()
            .haveRawType(java.util.Queue.class)
            .should()
            .haveFieldsThat()
            .haveRawType(ConcurrentLinkedQueue.class)
            .because("Use ConcurrentLinkedQueue for thread-safe queues in metrics collection");

    concurrentHashMapRule.check(importedClasses);
    concurrentQueueRule.check(importedClasses);
  }
}
