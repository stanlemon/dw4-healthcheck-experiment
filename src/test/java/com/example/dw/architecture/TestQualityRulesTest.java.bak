package com.example.dw.architecture;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.methods;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

@DisplayName("Test Quality Rules")
class TestQualityRulesTest {

  private static JavaClasses importedClasses;

  @BeforeAll
  static void setup() {
    importedClasses =
        new ClassFileImporter()
            .withImportOption(location -> location.contains("/test-classes/"))
            .importPackages("com.example.dw");
  }

  @Test
  @DisplayName("Test methods should follow naming convention")
  void testMethodsShouldFollowNamingConvention() {
    ArchRule rule =
        methods()
            .that()
            .areAnnotatedWith(Test.class)
            .and()
            .areDeclaredInClassesThat()
            .areNotAssignableTo(TestQualityRulesTest.class)
            .should()
            .haveNameMatching(".*_When.*_Should.*|.*_Given.*_When.*_Then.*")
            .because(
                "Test methods should follow naming convention: methodName_WhenCondition_ShouldExpectedResult");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Test classes should use @DisplayName annotations")
  void testClassesShouldUseDisplayNameAnnotations() {
    ArchRule rule =
        classes()
            .that()
            .haveSimpleNameEndingWith("Test")
            .and()
            .areNotAssignableTo(TestQualityRulesTest.class)
            .should()
            .beAnnotatedWith(DisplayName.class)
            .because(
                "Test classes should have descriptive @DisplayName annotations for better readability");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Test methods should use @DisplayName annotations")
  void testMethodsShouldUseDisplayNameAnnotations() {
    ArchRule rule =
        methods()
            .that()
            .areAnnotatedWith(Test.class)
            .and()
            .areDeclaredInClassesThat()
            .areNotAssignableTo(TestQualityRulesTest.class)
            .should()
            .beAnnotatedWith(DisplayName.class)
            .because(
                "Test methods should have descriptive @DisplayName annotations for better readability");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Complex test classes should use @Nested for organization")
  void complexTestClassesShouldUseNestedForOrganization() {
    ArchRule rule =
        classes()
            .that()
            .haveSimpleNameEndingWith("Test")
            .and()
            .haveMethodsThat()
            .areAnnotatedWith(Test.class)
            .and()
            .areDeclaredInClassesThat()
            .areNotAssignableTo(TestQualityRulesTest.class)
            .and()
            .haveMoreThan(5)
            .should()
            .haveMemberClassesThat()
            .areAnnotatedWith(Nested.class)
            .because(
                "Test classes with more than 5 test methods should use @Nested classes for better organization");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Tests should not overuse mocking")
  void testsShouldNotOveruseMocking() {
    ArchRule rule =
        noClasses()
            .that()
            .haveSimpleNameEndingWith("Test")
            .and()
            .areNotAssignableTo(TestQualityRulesTest.class)
            .should()
            .callMethodWhere(
                target ->
                    target.getOwner().isAssignableTo(Mockito.class)
                        && target.getName().startsWith("mock"))
            .andHave(
                clazz ->
                    clazz.getMethodCallsFromSelf().stream()
                            .filter(
                                call ->
                                    call.getTarget().getOwner().isAssignableTo(Mockito.class)
                                        && call.getTarget().getName().startsWith("mock"))
                            .count()
                        > 3)
            .because("Tests should avoid over-mocking - prefer real implementations when possible");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Integration tests should be in separate packages")
  void integrationTestsShouldBeInSeparatePackages() {
    ArchRule rule =
        classes()
            .that()
            .haveSimpleNameContaining("Integration")
            .or()
            .haveSimpleNameContaining("Functional")
            .should()
            .resideInAnyPackage("..functional..", "..integration..")
            .because("Integration and functional tests should be organized in separate packages");

    rule.check(importedClasses);
  }

  @Test
  @DisplayName("Test classes should have proper setup and teardown")
  void testClassesShouldHaveProperSetupAndTeardown() {
    ArchRule rule =
        classes()
            .that()
            .haveSimpleNameEndingWith("Test")
            .and()
            .areNotAssignableTo(TestQualityRulesTest.class)
            .and()
            .haveMethodsThat()
            .areAnnotatedWith(Test.class)
            .and()
            .haveMoreThan(3)
            .should()
            .haveMethodsThat()
            .areAnnotatedWith(org.junit.jupiter.api.BeforeEach.class)
            .or()
            .areAnnotatedWith(org.junit.jupiter.api.BeforeAll.class)
            .because(
                "Test classes with multiple tests should use proper setup methods (@BeforeEach or @BeforeAll)");

    rule.check(importedClasses);
  }
}
