# Coding Instructions

This Dropwizard application follows specific patterns for code quality, testing, and architecture.

## Code Quality Standards

### Thread.sleep() Elimination

**Never use `Thread.sleep()` in tests** - Use proper synchronization:

```java
// Bad - Flaky and unreliable
Thread.sleep(10);

// Good - Use CountDownLatch for synchronization
CountDownLatch threadStarted = new CountDownLatch(1);
threadStarted.countDown(); // Signal
threadStarted.await(1, TimeUnit.SECONDS); // Wait

// Good - Use Awaitility for condition-based waiting
await().atMost(Duration.ofSeconds(5))
       .pollInterval(Duration.ofMillis(100))
       .untilAsserted(() -> {
           assertThat(metrics.getLatency()).isGreaterThan(0);
       });
```

### Test Assertions

Use semantic assertions for better readability:

```java
// Bad
assertThat(count).isEqualTo(0);
assertThat(map.get("key")).isEqualTo(value);

// Good
assertThat(count).isZero();
assertThat(map).containsEntry("key", value);
```

### Exception Handling

Always preserve interrupt status:

```java
try {
    Thread.sleep(delayMs);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // Always restore interrupt status
    // Handle interruption appropriately
}
```

## Testing Patterns

### Test Structure

Follow Arrange-Act-Assert pattern:

```java
@Test
void testMethodName_WithSpecificCondition_ExpectedBehavior() {
    // Arrange - Setup test data
    metricsService.clearMetrics();

    // Act - Execute the operation
    metricsService.recordServerError();

    // Assert - Verify results
    assertThat(metricsService.getErrorCount()).isEqualTo(1);
}
```

### Test Types

- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Test component interactions with real implementations (prefer over mocking)
- **Thread Safety Tests**: Use concurrent testing for shared resources

### Test Performance

- Keep test delays minimal (â‰¤5ms for timing tests)
- Use deterministic approaches over actual delays
- Use real implementations instead of mocks when possible

## Dependencies and Libraries

### Preferred Testing Libraries

- **AssertJ**: For fluent assertions (`isZero()`, `containsEntry()`)
- **Awaitility**: For async/timing-based tests
- **JUnit 5**: For modern testing features
- **CountDownLatch**: For thread synchronization in tests
- **REST Assured**: For API integration testing and HTTP endpoint validation
- **WireMock**: For mocking external HTTP services and dependencies

### Production Libraries

- **Dropwizard**: Core framework
- **Jakarta**: Modern Java EE APIs
- **Atomic operations**: For thread-safe counters

## Architecture Patterns

### Metrics Collection

- Use atomic operations for thread-safe counters
- Implement circular buffers for time-series data
- Clear stale data proactively to prevent memory leaks

### Error Handling

All exceptions should flow through the global exception mapper to ensure:

- Consistent error responses
- Automatic metrics tracking
- Proper logging

### Health Checks

Implement comprehensive health checks that:

- Monitor both error rates and latency
- Use dynamic thresholds based on traffic
- Provide clear diagnostic messages

### Input Validation

- Validate all external inputs
- Use appropriate limits (e.g., max 10-second delays)
- Handle edge cases gracefully

## Code Formatting

Use Spotless with Google Java Format - apply before committing:

```bash
mvn spotless:apply
```

## Code Quality Tools

### SpotBugs
Write code that passes SpotBugs security analysis:
- Avoid security vulnerabilities and common bugs
- Handle null checks properly
- Use secure coding practices
- Close resources properly

### SonarQube Integration
Follow SonarQube quality standards:
- **Maintainability**: Keep methods focused and simple
- **Reliability**: Handle edge cases and exceptions properly
- **Security**: Validate inputs and handle secrets securely
- **Coverage**: Maintain high test coverage (70%+ minimum)
- **Code Smells**: Avoid anti-patterns like Thread.sleep() in tests

## Project Context

This is a Dropwizard application with:
- **Java 21** runtime
- **Metrics tracking** with dual thresholds (errors and latency)
- **Health monitoring** based on customer experience
- **Global exception handling** for consistent error tracking
- **Latency tracking filter** for all requests
- **Thread-safe metrics service** with circular buffers
