# Development Guidelines

This document provides essential information to help with development tasks in this repository.

## Key Information
- **Language**: Java 21
- **Architecture**: Microservice with REST API
- **Testing Framework**: JUnit 5 with Mockito, Rest Assured for integration tests
- **Code Quality**: Spotless for formatting, JaCoCo for coverage, SpotBugs for static analysis
- **Libraries**: Lombok for reducing boilerplate code, Dropwizard for REST API framework

## Development Commands

### Building and Testing
```bash
# Clean build with tests
mvn clean install

# Run tests only
mvn test

# Run specific test class
mvn test -Dtest=SpecificTest

# Generate code coverage report
mvn clean test jacoco:report

# View coverage report (macOS)
open target/site/jacoco/index.html

# Apply code formatting
mvn spotless:apply
```

## Testing Strategy

### Test Organization
- **Unit Tests**: Located in `src/test/java` mirroring the main source structure
- **Integration Tests**: Separate module for integration tests
- **Test Naming**: Descriptive method names with `@DisplayName` annotations
- **Test Structure**: Nested test classes using `@Nested` for logical grouping

### Test Patterns
- **Arrange-Act-Assert**: Follow this pattern for clarity
- **Mocking**: Use Mockito judiciously and as a last resort. Avoid over-mocking.
- **Assertions**: Use AssertJ for fluent assertions and readability
- **Test Coverage**: Focus on edge cases and exception handling
- **Naming**: `methodName_WhenCondition_ShouldExpectedResult`

### Thread.sleep() Elimination
**Never use `Thread.sleep()` in tests** - Use proper synchronization:

```java
// Bad - Flaky and unreliable
Thread.sleep(10);

// Good - Use CountDownLatch for synchronization
CountDownLatch threadStarted = new CountDownLatch(1);
threadStarted.countDown(); // Signal
threadStarted.await(1, TimeUnit.SECONDS); // Wait

// Good - Use Awaitility for condition-based waiting
await().atMost(Duration.ofSeconds(5))
       .pollInterval(Duration.ofMillis(100))
       .untilAsserted(() -> {
           assertThat(metrics.getLatency()).isGreaterThan(0);
       });
```

### Test Assertions
Use semantic assertions for better readability:

```java
// Bad
assertThat(count).isEqualTo(0);
assertThat(map.get("key")).isEqualTo(value);

// Good
assertThat(count).isZero();
assertThat(map).containsEntry("key", value);
```

### Test Coverage Requirements
- Comprehensive edge case testing (null values, empty strings, invalid inputs)
- Round-trip conversion testing for adapters/converters
- Exception scenario testing with proper assertions
- Mock verification for external dependencies
- Do not use `any()` in Mockito; use specific matchers or argument captors

### Test Performance
- Keep test delays minimal (â‰¤5ms for timing tests)
- Use deterministic approaches over actual delays
- Use real implementations instead of mocks when possible

## Code Quality

### Lombok Usage
Lombok is used extensively to reduce boilerplate code. Follow these guidelines when using Lombok:

```java
// For immutable value classes
@Value
public class ImmutableResponse {
    String message;
    int code;
    long timestamp;
}

// For data classes with getters, setters, equals, hashCode, and toString
@Data
public class StandardDto {
    private String name;
    private int value;
}

// For creating objects with the builder pattern
@Data
@Builder
public class ComplexObject {
    private String id;
    private String name;
    private List<String> tags;
}

// For Jackson deserialization
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse {
    private String status;
    private String message;
}
```

Key annotations to use:
- `@Value` - Creates immutable classes with getters, toString, equals, and hashCode
- `@Data` - Creates getters, setters, toString, equals, hashCode, and a required-args constructor
- `@Builder` - Creates a builder pattern implementation for the class
- `@NoArgsConstructor` - Creates a default constructor (required for Jackson deserialization)
- `@AllArgsConstructor` - Creates a constructor with parameters for all fields
- `@Slf4j` - Creates a logger field

### Exception Handling
Always preserve interrupt status:

```java
try {
    Thread.sleep(delayMs);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // Always restore interrupt status
    // Handle interruption appropriately
}
```

### Import Conventions
- **Avoid star imports**: Import specific classes rather than using wildcards
- **Use simple class names**: Import classes and use their simple names
- **Handle name collisions**: When class name collisions occur and one is from auto-generated code:
  - Import the auto-generated class
  - Use fully qualified name for the other class
- **Consistent import ordering**: Follow standard Java import ordering

### Code Formatting
Use Spotless with Google Java Format - apply before committing:

```bash
mvn spotless:apply
```

### Quality Tools
- **SpotBugs**: Avoid security vulnerabilities and common bugs
- **SonarQube**: Maintain high code quality (maintainability, reliability, security)
- **Test Coverage**: Maintain high test coverage (70%+ minimum)

## Architecture Patterns

### Metrics Collection
- Use atomic operations for thread-safe counters
- Implement circular buffers for time-series data
- Clear stale data proactively to prevent memory leaks

### Error Handling
All exceptions should flow through the global exception mapper to ensure:
- Consistent error responses
- Automatic metrics tracking
- Proper logging

### Health Checks
Implement comprehensive health checks that:
- Monitor both error rates and latency
- Use dynamic thresholds based on traffic
- Provide clear diagnostic messages

### Input Validation
- Validate all external inputs
- Use appropriate limits (e.g., max 10-second delays)
- Handle edge cases gracefully

## Common Issues to Watch For

### Data Conversion
- **Enum value matching**: Ensure enum values exactly match between adapters and enums
- **Case sensitivity**: Be careful with string comparisons for enum lookups
- **Round-trip conversion**: Always test both directions when converting data formats

### Constructor Behavior
- **Null handling variance**: Constructor null-handling varies by class
- Check existing implementations before assuming behavior

### External Services
- **Mock setup**: Ensure proper mock setup for external services
- Use argument captors for complex verifications

### Generated Code
- Do not modify generated code directly
- Create proper adapter layers between generated and hand-written code
- Handle null values and unexpected states from generated classes

## Additional Guidance

When working on this repository:

1. **Always read existing test files** before creating new tests
2. **Use the TodoWrite tool** to track multi-step tasks
3. **Follow existing code patterns**
4. **Add comments** for anything not obvious to a fourth grader
5. **Follow existing naming conventions**

## Dependencies and Libraries

### Preferred Testing Libraries
- **AssertJ**: For fluent assertions (`isZero()`, `containsEntry()`)
- **Awaitility**: For async/timing-based tests
- **JUnit 5**: For modern testing features
- **CountDownLatch**: For thread synchronization in tests
- **REST Assured**: For API integration testing and HTTP endpoint validation
- **WireMock**: For mocking external HTTP services and dependencies

### Dependency Management
- **Use Latest Versions**: Always prefer the latest stable versions
- **Keep Dependencies Current**: Regularly update existing dependencies
- **Security Updates**: Prioritize security patches and vulnerability fixes
- **Version Consistency**: Ensure compatible versions across related dependencies
- **Check CVEs**: Verify new dependencies don't introduce known vulnerabilities

## API Design Patterns

### Resource Design
- **RESTful URLs**: Use noun-based paths (`/users`, `/metrics`, not `/getUsers`)
- **HTTP Status Codes**: Use appropriate codes (200, 201, 400, 404, 500)
- **Path Parameters**: Validate all path parameters for format and existence
- **Query Parameters**: Provide sensible defaults and validate ranges

### Request/Response Patterns
```java
// Good - Clear DTOs with validation
@JsonProperty("delayMs")
@Min(0) @Max(10000)
private int delayMs;

// Good - Consistent error responses
public class ErrorResponse {
    private final String message;
    private final int code;
    private final long timestamp;
}
```

### Resource Method Structure
```java
@POST
@Path("/example")
public Response createExample(@Valid ExampleRequest request) {
    // 1. Validate input
    // 2. Business logic
    // 3. Return appropriate response with status code
}
```

## Logging Standards

### Structured Logging
```java
// Good - Use structured logging with context
log.info("Processing request - endpoint: {}, method: {}, requestId: {}",
         path, method, requestId);

// Good - Include relevant metrics
log.warn("High latency detected - endpoint: {}, latency: {}ms, threshold: {}ms",
         endpoint, actualLatency, threshold);
```

### Log Levels
- **ERROR**: System errors, exceptions that require immediate attention
- **WARN**: Potential issues, threshold breaches, recoverable errors
- **INFO**: Important business events, startup/shutdown, configuration changes
- **DEBUG**: Detailed flow information for troubleshooting (not in production)

### MDC (Mapped Diagnostic Context)
```java
// Add request correlation ID for tracing
MDC.put("requestId", UUID.randomUUID().toString());
try {
    // Process request
} finally {
    MDC.clear(); // Always clean up
}
```

## Security Best Practices

### Input Validation
```java
// Always validate and sanitize inputs
@Valid @NotNull ExampleRequest request

// Use appropriate limits
@Min(0) @Max(10000) int delayMs

// Validate string inputs
@Pattern(regexp = "^[a-zA-Z0-9_-]+$") String identifier
```

### Security Headers
```java
// Add security headers in responses
response.header("X-Content-Type-Options", "nosniff");
response.header("X-Frame-Options", "DENY");
response.header("X-XSS-Protection", "1; mode=block");
```

### Error Information Disclosure
```java
// Bad - Exposes internal details
throw new RuntimeException("Database connection failed: " + dbUrl);

// Good - Generic error with internal logging
log.error("Database connection failed", exception);
throw new ServiceUnavailableException("Service temporarily unavailable");
```

## Performance Guidelines

### Metrics Collection
```java
// Use atomic operations for thread-safe counters
private final AtomicLong counter = new AtomicLong(0);

// Implement efficient circular buffers for time-series data
// Clear stale data proactively to prevent memory leaks
```

### Resource Management
```java
// Always use try-with-resources for auto-closeable resources
try (Connection conn = dataSource.getConnection()) {
    // Use connection
}

// Pool expensive resources
// Monitor connection pool metrics
```

### Caching Strategies
- Cache frequently accessed, rarely changing data
- Use appropriate TTL values
- Monitor cache hit rates
- Implement cache warming for critical data

## Configuration Management

### Convention Over Configuration
- **Practical Defaults**: All configuration should have sensible defaults that work out-of-the-box
- **Minimal Required Config**: Only require explicit configuration for truly critical settings
- **Environment-Aware Defaults**: Use different defaults based on detected environment when appropriate

### Environment-Specific Configuration
```yaml
# config-dev.yml - Override only what differs from defaults
server:
  applicationConnectors:
    - type: http
      port: 8080  # Different from production default
logging:
  level: DEBUG    # More verbose for development

# config-prod.yml - Minimal overrides for production
server:
  applicationConnectors:
    - type: http
      port: 8097  # Production port
database:
  url: ${DATABASE_URL}  # Environment variable required in prod
  password: ${DATABASE_PASSWORD}  # Secret from environment
```

### Secret Management Through Environment Variables
```yaml
# Configuration files reference environment variables
database:
  url: ${DATABASE_URL:-jdbc:h2:mem:testdb}  # Default for dev/test
  username: ${DATABASE_USER:-sa}
  password: ${DATABASE_PASSWORD}  # Required in production, no default for security

# Application reads secrets through config, not directly
```

```java
// Good - Configuration class with defaults
public class DatabaseConfiguration {
    @JsonProperty("url")
    private String url = "jdbc:h2:mem:testdb";  // Sensible default

    @JsonProperty("username")
    private String username = "sa";  // Default for dev

    @JsonProperty("password")
    private String password;  // No default - must be provided in prod

    @JsonProperty("maxConnections")
    private int maxConnections = 10;  // Practical default
}
```

### Configuration Hierarchy
1. **Application Defaults** - Built into code, work for development
2. **Environment Config Files** - Override defaults per environment
3. **Environment Variables** - Secrets and deployment-specific values
4. **System Properties** - Runtime overrides (rare, for debugging)

### Critical Configuration Requirements
Only require explicit configuration when:
- **Security sensitive** (passwords, API keys, certificates)
- **Environment dependent** (database URLs, external service endpoints)
- **Business critical** (feature toggles that affect revenue/compliance)## Documentation Standards

### JavaDoc Requirements
```java
/**
 * Records a server error and updates error metrics.
 * This method is thread-safe and can be called concurrently.
 *
 * @throws IllegalStateException if metrics service is not initialized
 * @since 1.0
 */
public void recordServerError() {
    // Implementation
}
```

### API Documentation
- Use OpenAPI/Swagger annotations for REST endpoints
- Document all request/response schemas
- Include example requests and responses
- Document error codes and their meanings

### README Maintenance
- Keep endpoint documentation current
- Update build/run instructions
- Document environment setup requirements
- Include troubleshooting guides

## Git Workflow

### Pull Request Requirements
- **Descriptive title** following commit message format
- **Clear description** of changes and motivation
- **Test coverage** for new functionality
- **Documentation updates** if API changes
- **Code review approval** before merging
- **All checks passing** (tests, linting, security scans)