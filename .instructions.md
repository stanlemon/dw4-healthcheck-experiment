# Development Guidelines

This document provides essential information to help with development tasks in this repository.

## Key Information
- **Language**: Java 21
- **Framework**: Dropwizard 4.x (latest stable)
- **Architecture**: Microservice with REST API
- **Testing Framework**: JUnit 5 with Mockito, REST Assured for integration tests
- **Code Quality**: Spotless for formatting, JaCoCo for coverage, SpotBugs with FindSecBugs for security analysis
- **Architecture Testing**: ArchUnit for enforcing architectural constraints
- **Libraries**: Lombok for reducing boilerplate code, AssertJ for fluent assertions, Awaitility for async testing

_For exact dependency versions, see [pom.xml](pom.xml)_

## Maven Test Execution

**Important**: For all Maven test execution, use the `maven-test-runner` subagent instead of running Maven commands directly. The agent provides comprehensive test analysis, clear failure reporting, and actionable guidance.

### When to Use the Maven Test Runner Agent
- After making code changes to verify nothing is broken
- When implementing new features that need test validation  
- For debugging failing builds or CI issues
- To run specific test suites or individual test classes
- To generate and analyze code coverage reports

### Example Usage
```
"Run the test suite to make sure my changes didn't break anything"
"Execute mvn test and let me know if there are any failures"  
"Run the architecture tests to validate my refactoring"
"Check if all tests pass before I commit these changes"
```

## Development Commands

### Building and Testing
```bash
# Clean build with tests - USE MAVEN-TEST-RUNNER AGENT INSTEAD
mvn clean install

# Run tests only - USE MAVEN-TEST-RUNNER AGENT INSTEAD  
mvn test

# Run specific test class - USE MAVEN-TEST-RUNNER AGENT INSTEAD
mvn test -Dtest=SpecificTest

# Generate code coverage report - USE MAVEN-TEST-RUNNER AGENT INSTEAD
mvn clean test jacoco:report

# View coverage report (macOS)
open target/site/jacoco/index.html

# Apply code formatting
mvn spotless:apply

# Run the application
mvn exec:java

# Run architecture tests only - USE MAVEN-TEST-RUNNER AGENT INSTEAD
mvn test -Dtest="com.stanlemon.healthy.architecture.*"

# Run specific architecture test class - USE MAVEN-TEST-RUNNER AGENT INSTEAD  
mvn test -Dtest="com.example.dw.architecture.CodingRulesTest"

# Run security analysis with SpotBugs/FindSecBugs
mvn spotbugs:check

# Run SonarQube analysis (requires SonarCloud setup)
mvn sonar:sonar
```

**Note**: The Maven commands above are provided for reference. When you need to execute tests, request the `maven-test-runner` agent instead of running these commands directly.

## Testing Strategy

### Test Organization
- **Unit Tests**: Located in `src/test/java` mirroring the main source structure
- **Integration Tests**: Located in `src/test/java` alongside unit tests (e.g., `ResourceIntegrationTest`)
- **Functional Tests**: End-to-end tests located in `src/test/java/.../functional` package
- **Architecture Tests**: ArchUnit tests in `src/test/java/.../architecture` package
- **Test Naming**: Descriptive method names with `@DisplayName` annotations
- **Test Structure**: Nested test classes using `@Nested` for logical grouping

### Test Patterns
- **Arrange-Act-Assert**: Follow this pattern for clarity
- **Mocking**: Use Mockito judiciously and as a last resort. Avoid over-mocking.
- **Assertions**: Use AssertJ for fluent assertions and readability
- **Test Coverage**: Focus on edge cases and exception handling
- **Naming**: `methodName_WhenCondition_ShouldExpectedResult`

### Thread.sleep() Elimination
**Never use `Thread.sleep()` in tests** - Use proper synchronization:

```java
// Bad - Flaky and unreliable
Thread.sleep(10);

// Good - Use CountDownLatch for synchronization
CountDownLatch threadStarted = new CountDownLatch(1);
threadStarted.countDown(); // Signal
threadStarted.await(1, TimeUnit.SECONDS); // Wait

// Good - Use Awaitility for condition-based waiting
await().atMost(Duration.ofSeconds(5))
       .pollInterval(Duration.ofMillis(100))
       .untilAsserted(() -> {
           assertThat(metrics.getLatency()).isGreaterThan(0);
       });
```

### Test Assertions
Use semantic assertions for better readability:

```java
// Bad
assertThat(count).isEqualTo(0);
assertThat(map.get("key")).isEqualTo(value);

// Good
assertThat(count).isZero();
assertThat(map).containsEntry("key", value);
```

### Test Coverage Requirements
- Comprehensive edge case testing (null values, empty strings, invalid inputs)
- Round-trip conversion testing for adapters/converters
- Exception scenario testing with proper assertions
- Mock verification for external dependencies
- Do not use `any()` in Mockito; use specific matchers or argument captors

### Test Performance
- Keep test delays minimal (≤5ms for timing tests)
- Use deterministic approaches over actual delays
- Use real implementations instead of mocks when possible

### Test Execution Best Practices
**Always use the maven-test-runner agent for test execution** instead of running Maven commands directly. The agent provides:
- Comprehensive test result analysis and reporting
- Clear identification of failing tests with actionable guidance
- Performance monitoring and optimization suggestions
- Integration with quality tools (SpotBugs, Checkstyle, etc.)
- Consistent test execution feedback across the development workflow

## Code Quality

### Lombok Usage
Lombok is used extensively to reduce boilerplate code. Follow these guidelines when using Lombok:

```java
// For immutable value classes
@Value
public class ImmutableResponse {
    String message;
    int code;
    long timestamp;
}

// For data classes with getters, setters, equals, hashCode, and toString
@Data
public class StandardDto {
    private String name;
    private int value;
}

// For creating objects with the builder pattern
@Data
@Builder
public class ComplexObject {
    private String id;
    private String name;
    private List<String> tags;
}

// For Jackson deserialization
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse {
    private String status;
    private String message;
}
```

Key annotations to use:
- `@Value` - Creates immutable classes with getters, toString, equals, and hashCode
- `@Data` - Creates getters, setters, toString, equals, hashCode, and a required-args constructor
- `@Builder` - Creates a builder pattern implementation for the class
- `@NoArgsConstructor` - Creates a default constructor (required for Jackson deserialization)
- `@AllArgsConstructor` - Creates a constructor with parameters for all fields
- `@Slf4j` - Creates a logger field

### Exception Handling
Always preserve interrupt status:

```java
try {
    Thread.sleep(delayMs);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // Always restore interrupt status
    // Handle interruption appropriately
}
```

### Import Conventions
- **Avoid star imports**: Import specific classes rather than using wildcards
- **Use simple class names**: Import classes and use their simple names
- **Handle name collisions**: When class name collisions occur and one is from auto-generated code:
  - Import the auto-generated class
  - Use fully qualified name for the other class
- **Consistent import ordering**: Follow standard Java import ordering

### Code Formatting

**Important**: For code formatting, use the `maven-spotless-formatter` subagent instead of running Maven commands directly. The agent provides formatting verification, automatically applies fixes, and reports on style issues.

```bash
# Reference commands (use maven-spotless-formatter agent instead)
mvn spotless:check    # Check formatting without modifying files
mvn spotless:apply    # Apply formatting fixes automatically
```

This project uses Spotless with Google Java Format (version 1.19.2) with the following rules:
- Standard Google Java Style formatting
- Removal of unused imports
- Trimming of trailing whitespace
- Adding terminal newlines

### Quality Tools
- **SpotBugs**: Avoid security vulnerabilities and common bugs (use `maven-spotbugs-analyzer` agent)
- **FindSecBugs**: Security-focused static analysis plugin for SpotBugs
- **SonarCloud**: Maintain high code quality (maintainability, reliability, security)
- **Test Coverage**: Maintain high test coverage (70%+ minimum)
- **ArchUnit**: Architecture testing to enforce coding standards and design rules
- **Maven Enforcer**: Enforce dependency rules and security constraints

## ArchUnit Integration

ArchUnit is used to enforce architectural constraints and coding standards through executable tests.

### Architecture Test Categories

#### CodingRulesTest
Enforces general coding standards:
- **No java.util.Date usage** - Enforces modern `java.time` API
- **No generic exceptions** - Prevents `Exception`, `RuntimeException`, etc.
- **No java.util.logging** - Enforces SLF4J/Logback logging
- **No System.out/System.err** - Prevents console output in production
- **No Thread.sleep()** - Prevents flaky tests (except SlowResource demo)
- **No public fields** - Enforces encapsulation
- **No JUnit assertions** - Enforces AssertJ for readability

#### ArchitectureTest
Enforces architectural patterns:
- **Resource dependency isolation** - Resources depend on service interfaces only
- **Implementation hiding** - No dependencies on "Default*" implementations
- **Package organization** - Exception mappers in exceptions package
- **Naming conventions** - Resources end with "Resource", services with "Service"
- **REST patterns** - Resources must have `@Path` annotation

### Running ArchUnit Tests

**Use the maven-test-runner agent for all ArchUnit test execution:**

```
"Run all architecture tests to validate the code structure"
"Execute the CodingRulesTest to check for coding standard violations"  
"Run ArchitectureTest to verify architectural constraints"
"Check if the ArchUnit tests pass after my refactoring"
```

**Reference Commands** (use agent instead):
```bash
# Run all architecture tests - USE MAVEN-TEST-RUNNER AGENT INSTEAD
mvn test -Dtest="com.stanlemon.healthy.architecture.*"

# Run specific test classes - USE MAVEN-TEST-RUNNER AGENT INSTEAD
mvn test -Dtest="CodingRulesTest"
mvn test -Dtest="ArchitectureTest"
```

### Adding Custom ArchUnit Rules

Create new rules in `src/test/java/com/example/dw/architecture/`:

```java
@Test
@DisplayName("Services should not use static methods")
void servicesShouldNotUseStaticMethods() {
    ArchRule rule = noClasses()
        .that().resideInAPackage("..metrics..")
        .should().haveMethodsThat().areStatic()
        .because("Services should use dependency injection");
    
    rule.check(importedClasses);
}
```

## Security Analysis

### FindSecBugs Integration
FindSecBugs is integrated with SpotBugs for security-focused static analysis:

**Important**: For security analysis, use the `maven-spotbugs-analyzer` subagent instead of running Maven commands directly. The agent provides comprehensive bug analysis, security vulnerability detection, and actionable guidance.

```bash
# Reference commands (use maven-spotbugs-analyzer agent instead)
mvn spotbugs:check              # Fail build on errors
mvn clean compile spotbugs:spotbugs   # Generate report without failing build
```

The `maven-spotbugs-analyzer` agent will detect new issues in your code changes in real-time, helping you catch potential bugs before they get committed. It provides:

- Detection of thread safety issues
- Security vulnerability identification (via FindSecBugs)
- Potential performance problems
- Detailed explanation of each issue
- Suggested fixes with code examples
- Prioritized remediation plan

### Maven Enforcer Security Rules
The project uses Maven Enforcer Plugin to prevent vulnerable dependencies:

- **Log4j Security**: Bans vulnerable log4j versions (< 2.17.0)
- **Jackson Security**: Bans vulnerable Jackson versions (< 2.12.7.1)
- **Commons Collections**: Prevents security issues (< 3.2.2)
- **Lombok Compatibility**: Ensures Java 21 compatibility (>= 1.18.20)
- **Plugin Version Control**: Requires explicit plugin versions for reproducible builds

### SonarCloud Integration
Configured for continuous code quality analysis:

```bash
# Run SonarCloud analysis (requires setup)
mvn sonar:sonar

# With custom properties
mvn sonar:sonar -Dsonar.login=<token>
```

## Architecture Patterns

### Metrics Collection
- Use atomic operations for thread-safe counters
- Implement circular buffers for time-series data
- Clear stale data proactively to prevent memory leaks

### Error Handling
All exceptions should flow through the global exception mapper to ensure:
- Consistent error responses
- Automatic metrics tracking
- Proper logging

### Health Checks
Implement comprehensive health checks that:
- Monitor both error rates and latency
- Use dynamic thresholds based on traffic
- Provide clear diagnostic messages

### Input Validation
- Validate all external inputs
- Use appropriate limits (e.g., max 10-second delays)
- Handle edge cases gracefully

## Application Structure

### Component Registration Pattern
The application follows Dropwizard's standard component registration pattern in `DwApplication`:

```java
public void run(DwConfiguration configuration, Environment environment) {
    // 1. Create and register managed services as singletons
    final MetricsService metricsService = new DefaultMetricsService();
    
    // 2. Register filters (applied to all requests)
    environment.jersey().register(new LatencyTrackingFilter(metricsService));
    
    // 3. Register resources with dependency injection
    environment.jersey().register(new MetricsResource(metricsService));
    
    // 4. Register exception mappers for global error handling
    environment.jersey().register(new GlobalExceptionMapper(metricsService));
    
    // 5. Register health checks
    environment.healthChecks().register("application", 
        new ApplicationHealthCheck(metricsService));
}
```

### Package Structure
```
com.stanlemon.healthy.dw4app/
├── exceptions/          # Exception mappers and custom exceptions
├── filters/            # JAX-RS filters (e.g., latency tracking)
├── health/             # Dropwizard health checks
├── metrics/            # Metrics collection and services
├── resources/          # JAX-RS REST endpoints
├── DwApplication.java  # Main application class
└── DwConfiguration.java # Configuration class
```

### Dependency Injection Pattern
- **Services**: Created as singletons in the application class
- **Resources**: Receive service dependencies through constructor injection
- **Shared State**: Managed through service interfaces (`MetricsService`)
- **Global Components**: Exception mappers and filters receive service references

### Service Interface Pattern
All business logic is accessed through interfaces:
- `MetricsService` interface with `DefaultMetricsService` implementation
- Resources depend only on interfaces, not concrete implementations
- ArchUnit tests enforce this separation to maintain loose coupling

## Common Issues to Watch For

### Data Conversion
- **Enum value matching**: Ensure enum values exactly match between adapters and enums
- **Case sensitivity**: Be careful with string comparisons for enum lookups
- **Round-trip conversion**: Always test both directions when converting data formats

### Constructor Behavior
- **Null handling variance**: Constructor null-handling varies by class
- Check existing implementations before assuming behavior

### External Services
- **Mock setup**: Ensure proper mock setup for external services
- Use argument captors for complex verifications

### Generated Code
- Do not modify generated code directly
- Create proper adapter layers between generated and hand-written code
- Handle null values and unexpected states from generated classes

## Development Workflow

Follow this workflow when making changes to the codebase:

1. **Plan changes** using the TodoWrite tool to track multi-step tasks
2. **Make code changes** following the existing patterns and naming conventions
3. **Run Spotless** using the maven-spotless-formatter agent to ensure code is properly formatted
4. **Run SpotBugs** using the maven-spotbugs-analyzer agent to check for bugs and vulnerabilities
   - **CRITICAL: Always run SpotBugs after significant code changes**
   - This catches potential issues in real-time before they get committed
   - Prevents introducing thread safety, security, or logic bugs into the codebase
5. **Run Tests** using the maven-test-runner agent to verify your changes work correctly
6. **Commit** only after all three checks (formatting, bugs, tests) have passed

This workflow ensures that every change maintains code quality standards and doesn't introduce regressions. The real-time feedback loop between coding and quality checks is essential for maintaining codebase integrity.

## Additional Guidance

When working on this repository:

1. **Always read existing test files** before creating new tests
2. **Use the TodoWrite tool** to track multi-step tasks
3. **Use the maven-test-runner agent** for all Maven test execution instead of running commands directly
4. **Follow existing code patterns**
5. **Add comments** for anything not obvious to a fourth grader
6. **Follow existing naming conventions**
7. **Run maven-spotless-formatter agent** after every code change to ensure proper formatting
8. **Run maven-spotbugs-analyzer agent** regularly to catch potential bugs early

### Subagent Usage Guidelines
- **maven-test-runner**: Use for all test execution, validation, and coverage analysis
- **maven-spotbugs-analyzer**: Use for real-time static code analysis to find bugs and security vulnerabilities
  - Run after every significant code change
  - Essential for catching issues before they're committed
  - Provides detailed explanations and fix recommendations
- **maven-spotless-formatter**: Use for code formatting and style enforcement
- **TodoWrite**: Use for tracking progress on multi-step development tasks
- Request agents using natural language describing what you want to accomplish

### Creating Custom Claude Code Subagents

Subagents are a feature **exclusive to Claude Code** that automates specialized tasks with task-specific prompts. These instructions are specifically for creating Claude Code subagents and will not work with other LLM coding tools.

To create a new Claude Code subagent:

1. Create a Markdown file in the `.claude/agents/` directory with the following naming convention:
   - Use `maven-` prefix for Maven-related tools
   - Use a descriptive name that indicates the subagent's function
   - Example: `maven-spotbugs-analyzer.md`

2. Add Claude Code-specific frontmatter at the top of the file:
   ```
   ---
   name: maven-subagent-name
   description: Use this agent when... [include usage examples]
   model: sonnet
   color: green  # Choose a color that distinguishes this subagent
   ---
   ```

3. Structure the Claude Code subagent content with:
   - Clear title and introduction explaining the subagent's purpose
   - Command section showing the exact commands to run
   - Process section detailing the steps to analyze output
   - Report format section specifying how results should be presented
   - Include troubleshooting guidance for common errors

4. Include example usage in the description to help Claude understand when to invoke the subagent:
   ```
   <example>Context: User wants to... user: "..." assistant: "I'll use the maven-subagent-name..."</example>
   ```

Once created, the subagent will be available only in Claude Code through the slash command `/maven-subagent-name`. These subagents leverage Claude's capabilities to provide specialized functionality that goes beyond simple command execution.

## Dependencies and Libraries

### Preferred Testing Libraries
- **AssertJ**: For fluent assertions (`isZero()`, `containsEntry()`)
- **Awaitility**: For async/timing-based tests
- **JUnit 5**: For modern testing features
- **CountDownLatch**: For thread synchronization in tests
- **REST Assured**: For API integration testing and HTTP endpoint validation
- **WireMock**: For mocking external HTTP services and dependencies

### Dependency Management
- **Use Latest Versions**: Always prefer the latest stable versions
- **Keep Dependencies Current**: Regularly update existing dependencies
- **Security Updates**: Prioritize security patches and vulnerability fixes
- **Version Consistency**: Ensure compatible versions across related dependencies
- **Check CVEs**: Verify new dependencies don't introduce known vulnerabilities

## API Design Patterns

### Resource Design
- **RESTful URLs**: Use noun-based paths (`/users`, `/metrics`, not `/getUsers`)
- **HTTP Status Codes**: Use appropriate codes (200, 201, 400, 404, 500)
- **Path Parameters**: Validate all path parameters for format and existence
- **Query Parameters**: Provide sensible defaults and validate ranges

### Request/Response Patterns
```java
// Good - Clear DTOs with validation
@JsonProperty("delayMs")
@Min(0) @Max(10000)
private int delayMs;

// Good - Consistent error responses
public class ErrorResponse {
    private final String message;
    private final int code;
    private final long timestamp;
}
```

### Resource Method Structure
```java
@POST
@Path("/example")
public Response createExample(@Valid ExampleRequest request) {
    // 1. Validate input
    // 2. Business logic
    // 3. Return appropriate response with status code
}
```

## Logging Standards

### Structured Logging
```java
// Good - Use structured logging with context
log.info("Processing request - endpoint: {}, method: {}, requestId: {}",
         path, method, requestId);

// Good - Include relevant metrics
log.warn("High latency detected - endpoint: {}, latency: {}ms, threshold: {}ms",
         endpoint, actualLatency, threshold);
```

### Log Levels
- **ERROR**: System errors, exceptions that require immediate attention
- **WARN**: Potential issues, threshold breaches, recoverable errors
- **INFO**: Important business events, startup/shutdown, configuration changes
- **DEBUG**: Detailed flow information for troubleshooting (not in production)

### MDC (Mapped Diagnostic Context)
```java
// Add request correlation ID for tracing
MDC.put("requestId", UUID.randomUUID().toString());
try {
    // Process request
} finally {
    MDC.clear(); // Always clean up
}
```

## Security Best Practices

### Input Validation
```java
// Always validate and sanitize inputs
@Valid @NotNull ExampleRequest request

// Use appropriate limits
@Min(0) @Max(10000) int delayMs

// Validate string inputs
@Pattern(regexp = "^[a-zA-Z0-9_-]+$") String identifier
```

### Security Headers
```java
// Add security headers in responses
response.header("X-Content-Type-Options", "nosniff");
response.header("X-Frame-Options", "DENY");
response.header("X-XSS-Protection", "1; mode=block");
```

### Error Information Disclosure
```java
// Bad - Exposes internal details
throw new RuntimeException("Database connection failed: " + dbUrl);

// Good - Generic error with internal logging
log.error("Database connection failed", exception);
throw new ServiceUnavailableException("Service temporarily unavailable");
```

## Performance Guidelines

### Metrics Collection
```java
// Use atomic operations for thread-safe counters
private final AtomicLong counter = new AtomicLong(0);

// Implement efficient circular buffers for time-series data
// Clear stale data proactively to prevent memory leaks
```

### Resource Management
```java
// Always use try-with-resources for auto-closeable resources
try (Connection conn = dataSource.getConnection()) {
    // Use connection
}

// Pool expensive resources
// Monitor connection pool metrics
```

### Caching Strategies
- Cache frequently accessed, rarely changing data
- Use appropriate TTL values
- Monitor cache hit rates
- Implement cache warming for critical data

## Configuration Management

### Convention Over Configuration
- **Practical Defaults**: All configuration should have sensible defaults that work out-of-the-box
- **Minimal Required Config**: Only require explicit configuration for truly critical settings
- **Environment-Aware Defaults**: Use different defaults based on detected environment when appropriate

### Environment-Specific Configuration
```yaml
# config-dev.yml - Override only what differs from defaults
server:
  applicationConnectors:
    - type: http
      port: 8080  # Different from production default
logging:
  level: DEBUG    # More verbose for development

# config-prod.yml - Minimal overrides for production
server:
  applicationConnectors:
    - type: http
      port: 8097  # Production port
database:
  url: ${DATABASE_URL}  # Environment variable required in prod
  password: ${DATABASE_PASSWORD}  # Secret from environment
```

### Secret Management Through Environment Variables
```yaml
# Configuration files reference environment variables
database:
  url: ${DATABASE_URL:-jdbc:h2:mem:testdb}  # Default for dev/test
  username: ${DATABASE_USER:-sa}
  password: ${DATABASE_PASSWORD}  # Required in production, no default for security

# Application reads secrets through config, not directly
```

```java
// Good - Configuration class with defaults
public class DatabaseConfiguration {
    @JsonProperty("url")
    private String url = "jdbc:h2:mem:testdb";  // Sensible default

    @JsonProperty("username")
    private String username = "sa";  // Default for dev

    @JsonProperty("password")
    private String password;  // No default - must be provided in prod

    @JsonProperty("maxConnections")
    private int maxConnections = 10;  // Practical default
}
```

### Configuration Hierarchy
1. **Application Defaults** - Built into code, work for development
2. **Environment Config Files** - Override defaults per environment
3. **Environment Variables** - Secrets and deployment-specific values
4. **System Properties** - Runtime overrides (rare, for debugging)

### Critical Configuration Requirements
Only require explicit configuration when:
- **Security sensitive** (passwords, API keys, certificates)
- **Environment dependent** (database URLs, external service endpoints)
- **Business critical** (feature toggles that affect revenue/compliance)## Documentation Standards

### JavaDoc Requirements
```java
/**
 * Records a server error and updates error metrics.
 * This method is thread-safe and can be called concurrently.
 *
 * @throws IllegalStateException if metrics service is not initialized
 * @since 1.0
 */
public void recordServerError() {
    // Implementation
}
```

### API Documentation
- Use OpenAPI/Swagger annotations for REST endpoints
- Document all request/response schemas
- Include example requests and responses
- Document error codes and their meanings

### README Maintenance
- Keep endpoint documentation current
- Update build/run instructions
- Document environment setup requirements
- Include troubleshooting guides

## Git Workflow

### Pull Request Requirements
- **Descriptive title** following commit message format
- **Clear description** of changes and motivation
- **Test coverage** for new functionality
- **Documentation updates** if API changes
- **Code review approval** before merging
- **All checks passing** (tests, linting, security scans)